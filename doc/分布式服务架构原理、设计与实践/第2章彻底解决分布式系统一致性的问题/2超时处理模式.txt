1、同步调用模式：
	服务1调用服务2，服务1的线程阻塞等待服务2返回处理结果，如果服务2一直不返回结果，则服务1一直等待到超时为止
	适用于大规模、高并发的短小操作，而不适用于后端负载较高的场景
	超时采用重试策略(保证幂等性)，调用前记录ready日志，记录下次补偿轮询的时间点，如果收到服务方的返回，就把ready日志转移到finish；如果多次轮询获取
	不到结果就转移到error。

2、接口异步调用模式：
	服务1请求服务2受理某项任务，服务2受理后即刻返回给服务1其受理结束，如果受理成功，则服务1继续做其它任务，而服务2异步的处理这项任务，直到服务2处理
	完这项任务后，才反向的通知服务1任务已经完成，服务1再做后续处理
	适用于非核心链路负载较高的处理环节，这个环节经常耗时较长，并且对实时性要求不高。
	超时采用重试策略(保证幂等性)，调用前记录ready日志，记录下次补偿轮询的时间点，服务方返回时，带一个大概需要执行多久的时间，然后调用方更新ready记
	录的完结时间点；服务方在处理完后，会回调调用方，但无需保证一定成功；定时补偿程序会轮询ready记录，把到达执行时间点的ready请求进行重试。

3、消息队列异步处理模式：
	应用于非核心链路负载较高的处理环节中，并且服务的上游不关心下游的处理结果，下游也不需要向上游返回处理结果。

尝试补偿原则：
	1、服务1调用服务2，如果服务2响应服务1并且告诉服务1消息已接收，那么服务1的任务就结束了；如果服务2处理失败，那么服务2应该负责重试或者补偿。在这种
	情况下，服务2通常接收消息后先持久化再告诉服务1接收成功，随后服务2才开始处理持久的消息，避免服务进程被杀掉而导致消息丢失。
	2、服务1调用服务2，如果服务2没有给出明确的接收响应，例如网络超时，那么服务1应该持续进行重试，直到服务2明确表明已经接收消息。这种情况下容易出现重
	复的消息，因此在服务2中通常要保证滤重和幂等性。