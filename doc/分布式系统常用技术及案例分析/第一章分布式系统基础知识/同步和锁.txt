内部锁和同步：
	每一个对象都有一个与之相关联动的内部锁。按照传统的做法，当一个线程需要对一个对象的字段进行排他性访问并保持访问的一致性时，他必
	须在访问前先获取对象的内部锁，然后才能访问之，最后释放该内部锁。在线程获取对象的内部锁到释放对象的内部锁的这段时间，我们你说该
	线程拥有该对象的内部锁。只要有一个线程已经拥有了一个内部锁，其它线程就不能再拥有该锁了，其它线程在试图获取该锁的时候都会被阻塞
	了。

同步方法中的锁：
	当一个线程调用一个同步方法时，它就自动获得了该方法所属对象的内部锁，并在方法返回的时候释放锁，即使由于出现了没有被捕获的异常而
	导致方法返回，该锁也会被释放。

同步语句：
	另外一种创建同步代码的方式就是使用同步语句。和同步方法不同，使用同步语句必须指明使用哪个对象的内部锁：
	public void addName(String name){
		synchronized(this){
			lastName = name;
			nameCount++;
		}
	}

在改善并发性方面，巧妙的使用同步语句能起到很大的作用，例如，我们假定类MsLunch有两个实例字段，c1、c2，这两个变量绝不会一起使用，所
有对这两个变量的更新都需要进行同步。但是没有理由阻止对c1的更新和对c2的更新出现交错——这样做会创建不必要的阻塞，进而降低并发性。此时，
我们没有使用同步方法或使用和this相关的锁，而是创建了两个单独的对象来提供锁：
	public class MsLunch{
		private long c1 = 0;
		private long c2 = 0;
		private Object lock1 = new Object();
		private Object lock2 = new Object();

		public void inc1(){
			synchronized(lock1){
				c1++;
			}
		}
		public void inc2(){
			synchronized(lock2){
				c2++;
			}
		}
	}
	采用这种方式要小心，我们必须保证相关字段的访问交错是完全安全的。